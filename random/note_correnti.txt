Sono alla parte in cui sto facendo codice.
Attenzione perché nell'esecuzione delle cose i class diagrams stanno venendo leggermente modificati
Mi accorgo ora che le bounderies dovrebbero avere un pezzo di codice secondo qui: 
	Il listener di un bottone che porta ad un altro caso d'uso non fa altro che cambiare la nuova boundery nella classe sessione e poi ritornare.
	Non ha senso che parta il controller del relativo caso d'uso se sto cambiando caso d'uso.

Devo riflette sul caso senza persistenza. In teoria è molto semplice. Si fa un inizializzatore che avvia delle classi di dati non persistenti (ad esempio discounts oppure loan posts etc.)
da lì si usano getters e setters che tutte le classi hanno per compiere le modifiche non persistenti. In questo senso i metodi di classe perdono un pò senso però e bastano setters e getters

Credo di essermi scordato le boundery di errore, quelle cui dovrebbe arrivare un messaggio di errore da mostrare all'utente
Da Chat sembra che il controllo di errore di flusso vada fatto come ti aspetti. Generalmente le eccezzioni avvengono nella logica applicativa quindi o nelle entities o nei dao.
In tal caso la giusta propagazione consiste nel catchare l'eccezione specifica di livello applicativo (SQL_Exception) e poi propagarla in alto in modo più generale (magari facendone una custom)
da lì è il controller a gestirla, in qusto caso ha senso anche che istanzi e avvii una classe Errore_Boundery dato che questa non ascolta attivamente (e lì si mescolerebbero i compiti).

Ok lo scheletro dell'autenticazione c'è ma prima di andare avanti a fare codice devi avere chiaro quale sarà il modo in cui realizzi la NoPersistency, la fabbrica di connessioni per il DB e la Session_Info,
e le bounderies.

Questo significa che la prossima volta non andare avanti con il prossimo caso d'uso. FINISCI PER BENE QUESTO perché tanto incontreresti gli stessi problemi ovunque dopo.

- Capisci come mettere bene questo sigleton di Session Info (!)
- Capisci come mettere bene questa factory di Connessioni a DB (!)
- Capisci quale è la dinamica della persistency su File (!)
- Capisci quale è la dinamica della persistency su NoPersistence (!)
- Capisci come far funzionare le bounderies


SINGLETON:
Il patterns singleton in questo caso è utilizzato quando voglio avere un punto di accesso unico per informazioni globali (come dettagli di sessione)
Il pattern consiste in una classe che ha:
	Come attributo un riferimento a sè stessa (e altri in caso)
	Un costruttore privato (di modo che solo lei stessa possa crearsi)
	Un metodo che ritorna l'istanza (e la crea nel caso non sia già creata)

Nota: In questo senso allora non c'è qualcuno che deve creare l'istanza di singleton, semplicemente vengono settati i suoi valori.

Allora una classe singleton "Session_Info" dovrebbe avere la forma:

public class Session_Info{
	private Session_Info instance;

	//Attributi privati necessari al funzionamento (User, NextBoundery)

	private Session_Info(){
	}

	public static Session_Info getSessionInfo(){
		if(instance == 0){
			instance = new SessionInfo()
		}
		return instance;
	}

	//getters e sets

}



CONNECTION_FACTORY:

Qui è semplice perché copio pari pari da BD.
La dimanica della cosa è che c'è una classe connection factory con un pezzo di codice statico che viene eseguito ogni volta che viene chiamato un metodo statico di questa classe (ne ha 1).

Il blocco di codice statico semplicemente si connette al DB con l'utente di login.
Il metodo statico (quello che viene effettivamente chiamato per avviare la connessione al DB) cambia l'utente alla connessione creata di modo tale da avere maggiori privilegi.
Questi metodi si interfacciano al file "db.properties" da cui traggono la stringa di connessione al db e il nome degli utenti.
Ovviamente nel db ci si aspetta che ci siano altrettanti utenti con uguali identificatori.

Nel blocco statico sono presenti delle eccezioni che vengono catturate e gestite lì per lì. Questo non è esattamente corretto dato che dovrebbe essere
il controller a gestire le eccezioni (e quindi il dao che è la classe che chiama ConnectionFactory dovrebbe solo propagarle).
Ma ha senso farlo ? Quello è un blocco di codice statico, come faccio a fargli tirare una nuova eccezione ? Probabilmente semplicemente gliela faccio tirare
e metto il blocco di codice di dao che esegue il comando per le connessioni in un try-catch


CONCETTO IMPORTANTE: Non è che solo il controller deve avere try-catch, tutte le classi possono averle semplicemente che le altre classi le propagano mentre
il controller gestisce le eccezioni (più generali rispetto a quelle catturate dalle altre classi) ad alto livello.



DINAMICA DELLA PERSISTENCY SU FILE:

Tocca farlo Json. I file Json sono file con una formattazione molto leggibile e intuitiva.
Dovresti averne uno per tipo di entita nel tuo dominio. Gli esempi te li dà chat.

La dinamica della lettura file su json in java è articolata dalla libreria Jackson. Questa libreria mette a disposizione l'oggetto focali:
- ObjectMapper: E' l'oggetto che legge file Json, e li traduce in oggetti Java tramite il metodo readValue. Laddove ci sono più oggetti nel Json puoi
renderlo uguale ad una lista di oggetti Java.

La dinamica della scrittura file su json in java è articolata dalla libreria Jackson. Questa libreria mette a disposizione 2 oggetti focali:
- ObjectMapper: E' l'oggetto che legge file Json e può scriverci sopra via JsonNode.
- JsonNode: E' l'oggetto che traduce tipi di dato Java in Json, devi popolarlo con quello che vuoi che venga messo nel file Json e poi darlo in pasto a ObjectMapper per scrivere su file.



DINAMICA DELLA NO PERSISTENCY
L'idea migliore che ho è utilizzare una classe che funziona da repository (ovvero un db volatile). Questa racchiude i dati che l'applicazione necessita per funzionare senza persistenza.

In questo senso ogni entita di dominio avrebbe una propria classe singleton "Entity_Repository" che immagazzina i dati delle istanze volatili ed esegue le operazioni crud su di esse.

In questo senso il dispatcher dovrebbe occuparsi di popolare le classi Repositories all'avvio in caso l'utente scelga la relativa persistency_policy.


BOUNDERIES:
Dai su che è facile. Semplicemente devi creare un JFrame che contiene i bottoni e i listeners e così via.
Lo fai una volta sai come farlo per tutte le altre.



DA QUI:
Sistemiamo il singelton Session_Info. Singleton a posto.
Connessione a DB fatta. Creo USER_DAO però e annesse classi implementatrici. Fatto.
Mi occupo della boundery di log in


Sto capendo diverse cose sul come funziona Swing. Sai che JFrame è la tela su cui metti su bottoni textboxes etc.
Ogni elemento è una istanza di classe a sè stante quindi ti chiedi: Cosa succede se dopo aver ricevuto un input voglio far ritornare ad un mio componente un tipo di dato ? Se lo fai la componente GUI che ritorna NON smette di esistere e tanto meno di essere visible.

Allora devo fare il setVisible(false) di ogni componente nel JFrame ? No se setti setVisible(false) SUL JFRAME allora tutto ciò che è contenuto al suo interno smette di essere visibile. Il Jframe quindi è una "masterclass". Se la GUI non ti serve più probabilmente è meglio utilizzare il metodo dispose() che chiude e libera risorse.

Un dubbio che ho è l'action listener passato con casting ai componenti interagibili della gui da MainFrame

L'idea di utilizzare custom button è che posso riutilizzare la classe per ogni bottone che mi serve e far specializzare quello che devo al relativo MainFrame

Usi getText per ottenere il testo che è correntemente mostrato nel textfield. Lo fai quando un bottone è premuto (quello di login nel caso in cui sto lavorando adesso)

Sono arrivato ad un problema: Supponendo che la GUI sia fatta da un mainframe che contiene JPannels che a loro volta contengono bottoni, la domanda allora è: Dove metto gli action listener ? Dove metto la logica di gestione delle interruzioni?
La risposta è: NON nei Jpannels. La logica di gestione dovrebbe essere nel mainFrame (anche perché poi è quello che fa partire il controller).

Ma quindi come si fa ? Sembra che il modo più corretto di farlo sia inizializzare i JPannels con i bottoni e poi da mainframe aggiungere ai bottoni l'action listener.

Andrebbe fatta una eccezione personalizzata "dao EXCEPTION" se qualcosa inerente al dao schianta.

COSA BISGONA FARE A QUESTO PUNTO ?

Sistemare DAOs
Verificare funzionalità


Ho appena pensato ad una brutta cosa... Per il modo in cui lo ho gestito ogni controller corrente chiama la successiva boundery, ma in questo modo tutti i controller
che verrano saranno sempre legati a quelli prima quindi il garbage collector non può eliminare niente. E' giusto ? In caso come risolvo. Non lo so ora non ho la testa per farlo
Non succede fortunatamente sembra che quelli di Swing ci abbiano pensato o che comunque finché è aperto un thread il programma non si chiuda.


Sono arrivato alla conclusione che:
Il mainframe di una boundery ha la responsabilità di raccogliere tutti i componenti, disporli e renderli visibili. Si comporta come una sorta di facade.
I pannels sono i contenitori a grana fine, questi hanno la responsabilità di mostrare gli elementi interagibili e AVVIARE l'interazione. Nel caso l'interaizione
scateni un caso d'uso si sta usando il pannello principale e questo avrà il relativo controller.
Nel caso in cui si stia navigando nell'app (si passa da un caso d'uso all'altro o si va all'homepage) si sta usando il pannello di navigazione che invece
non scatena un controller ma setta la nextBoundery nella classe di sessione
